# 해커 지망자들이 알아야 할 Buffer Overflow Attack의 기초

## 8086 Memory Architecture
+ **code segment**에는 시스템이 알아들을 수 있는 명령어. 즉, instruction들이 들어 있다. 이것은 기계어 코드로써 컴파일러가 만들어낸 코드이다.
segment는 자신이 현재 메모리 상에 어느 위치에 저장될지 컴파일 과정에서는 알 수 없기 때문에 정확한 주소를 지정할 수 없다.
따라서 segment에서는 logic address를 사용한다. Logical address는 실제 메모리 상의 주소와 매핑되어 있다.
즉 segment는 segment selector에 의해서 자신의 시작 위치(offset)를 찾을 수 있고 자신의 시작 위치로부터의 위치(logical address)에 있는 명령을 수행할 지를 결정하게 되는 것이다.
실제 메모리 주소 physical address는 offset + logical address라고 할 수 있다.
+ **data segment**에는 프로그램이 실행시에 사용되는 데이터가 들어간다. 여기서 말하는 데이터는 전역변수이다. 프로그램 내에서 전역 변수를 선언하면
그 변수가 data segment에 자리잡게 된다.
+ **stack segment**는 현재 수행되고 있는 handler, task, program이 저장하는 데이터 영역으로 우리가 사용하는 버퍼가 바로 이 stack segment에 자리잡게 된다.
지역 변수들이 자리 잡는 공간이다.
+ stack은 처음 생성될 때 그 필요한 크기만큼 만들어지고 프로세스의 명령에 의해 데이터를 저장해 나가는 과정을 거치게 되는데 이것은 **stack pointer(SP)**라고 하는
레지스터가 스텍의 맨 꼭대기를 가리키고 잇다. 스텍에 데이터를 저장하고 읽어 들이는 과정은 PUSH와 POP instruction에 의해서 수행된다.
   
## 8086 CPU 레지스터 구조
   
+ **범용 레지스터**는 논리 연산, 수리 연산에 사용되는 피연산자, 주소를 계산하는데 사용되는 피연산자, 그리고 메모리 포인터가 저장되는 레지스터이다.
 => EAX, EBX, ECX, EDX, EBP, ESI, EDI, ESP
+ **세그먼트 레지스터**는 code segment, data segment, stack segment를 가리키는 주소가 들어있는 레지스터이다.
  => CS, DS, SS, ES, FS, GS
+ **플레그 레지스터**는 프로그램의 현재 상태나 조건 등을 검사하는데 사용되는 플래그들이 있는 레지스터이다.
+ **인스트럭션 포인터**는 다음 수행해야 하는 명령이 있는 메모리 상의 주소가 들어가 있는 레지스터이다.
  => EIP
  
  ## 프로그램 구동 시 Segment에서는 어떤 일이 일어나는가
  ```C
  void function(int a, int b, int c)
  {
      char bufer1[15];
      char buffer2[10];
  }
  
  void main()
  {
      function(1,2,3);
  }
  ```
  
  
  
