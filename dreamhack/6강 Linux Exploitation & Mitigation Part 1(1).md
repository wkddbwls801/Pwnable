# ELF 동적 분석
* 예제
```C
// gcc -o example0 example0.c -m32
#include <stdio.h>
int main(void){
  int sum = 0;
  int val1 = 1;
  int val2 = 2;
  sum = val1 + val2;
  printf("1 + 2 = %d\n", sum);
  return 0;
}
```
gdb에서 함수의 디스어셈블리 결과를 출력해주는 명령어는 disassemble(disas)이다. disas 명령어를 사용해 main 함수의 디스어셈블리 결과를 보자.
```
(gdb) disas main
Dump of assembler code for function main:
   0x0804840b <+00>:	push   ebp
   0x0804840c <+01>:	mov    ebp,esp
   0x0804840e <+03>:	sub    esp,0xc
   0x08048411 <+06>:	mov    DWORD PTR [ebp-0x4],0x0
   0x08048418 <+13>:	mov    DWORD PTR [ebp-0x8],0x1
   0x0804841f <+20>:	mov    DWORD PTR [ebp-0xc],0x2
   0x08048426 <+27>:	mov    edx,DWORD PTR [ebp-0x8]
   0x08048429 <+30>:	mov    eax,DWORD PTR [ebp-0xc]
   0x0804842c <+33>:	add    eax,edx
   0x0804842e <+35>:	mov    DWORD PTR [ebp-0x4],eax
   0x08048431 <+38>:	push   DWORD PTR [ebp-0x4]
   0x08048434 <+41>:	push   0x80484d0
   0x08048439 <+46>:	call   0x80482e0 <printf@plt>
   0x0804843e <+51>:	add    esp,0x8
   0x08048441 <+54>:	mov    eax,0x0
   0x08048446 <+59>:	leave  
   0x08048447 <+60>:	ret    
End of assembler dump.
(gdb) 
```
0x804842e 주소에 breakpoint를 설정해 val1+val2의 결과값이 저장되는 eax 레지스터의 값을 보자.
gdb에서 breakpoint를 설정하는 명령어는 break(b)이다.
```
(gdb) b *0x804842e
Breakpoint 1 at 0x804842e
(gdb) info break
Num     Type           Disp Enb Address    What
1       breakpoint     keep y   0x0804842e <main+35>
(gdb) 
```
디버깅 중인 프로세스의 정보를 출력해주는 명령어인 info를 사용해 breakpoint가 정상적으로 설정된 것을 확인할 수 있다.   
프로세스를 실행시켜주는 명령어인 run(r)을 이용해 breakpoint가 설정된 지점까지 example0을 실행시켜보자.
```
(gdb) r
Starting program: ~/example0 
Breakpoint 1, 0x0804842e in main ()
(gdb) info reg
eax            0x3	3
ecx            0x97b9e553	-1749424813
edx            0x1	1
ebx            0x0	0
esp            0xffffd5dc	0xffffd5dc
ebp            0xffffd5e8	0xffffd5e8
esi            0xf7fb2000	-134537216
edi            0xf7fb2000	-134537216
eip            0x804842e	0x804842e <main+35>
eflags         0x206	[ PF IF ]
cs             0x23	35
ss             0x2b	43
ds             0x2b	43
es             0x2b	43
fs             0x0	0
gs             0x63	99
(gdb) 
```
eip 레지스터가 0x804842e인 것으로 보아 breakpoint를 설정했던 위치에서 실행이 멈춘 것을 확인 할 수 있다.
레지스터나 변수의 값을 출력시켜주는 print(p) 명령어를 이용해 val1+val2의 결과가 저장되어 있는 eax 레지스터의 값을 출력해보자.
```
(gdb) p $eax
$1 = 3
(gdb) 
```
0x8048439 주소에 breakpoint를 설정해 printf 함수의 인자들을 살펴보도록 하자.   
프로세스가 멈추어있는 상태에서 프로세스를 이어서 실행시켜주는 명령어는 continue(c)이다. 만약 breakpoint가 설정디어 있다면 다음 breakpoint 지점까지 프로세스를 실행시킨다.
```
(gdb) b*0x8048439
Breakpoint 2 at 0x8048439
(gdb) c
Continuing.
Breakpoint 2, 0x08048439 in main ()
(gdb) 
```
스택 메모리를 살펴보자.   
x 명령어를 사용하면 인자로 주어진 주소의 메모리를 볼 수 있다.
x 명령어는 또한 출력 타입을 지정해 줄 수 있다. 우선 esp 레지스터의 메모리를 word 타입으로 2개만큼(x/2wx) 출력해보자
```
(gdb) x/2wx $esp
0xffffd544:	0x080484d0	0x00000003
```
첫 번째 인자인 '1+2=%d\n' 문자열의 주소 0x80484d0을 문자열 형태로(x/s) 출력해보자.
```
(gdb) x/s 0x080484d0
0x80484d0:	"1 + 2 = %d\n"
(gdb) 
```
마지막으로 함수의 다음 인스트럭션까지 실행해주는 nexti(ni) 명령어를 이용해 printf 함수를 실행해보자.
```
(gdb) x/i $eip
=> 0x8048439 <main+46>:	call   0x80482e0 <printf@plt>
(gdb) ni
1 + 2 = 3
0x0804843e in main ()
(gdb) x/i $eip
=> 0x804843e <main+51>:	add    esp,0x8
(gdb) 
```










